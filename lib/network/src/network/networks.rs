use std::{
    net::{Ipv4Addr, Ipv6Addr, SocketAddr},
    sync::Arc,
};

use base::system::System;
use serde::Serialize;

use super::{
    connection::NetworkConnectionId,
    errors::KickType,
    event_generator::NetworkEventToGameEventGenerator,
    network::Network,
    notifier::NetworkEventNotifier,
    plugins::NetworkPlugins,
    traits::{
        NetworkConnectingInterface, NetworkConnectionInterface, NetworkEndpointInterface,
        NetworkIncomingInterface,
    },
    types::{
        NetworkInOrderChannel, NetworkServerCertMode, NetworkServerCertModeResult,
        NetworkServerInitOptions,
    },
};

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum NetworkTypes {
    QuicIpv4,
    QuicIpv6,
}

pub struct Networks<E, C, Z, I>
where
    C: NetworkConnectionInterface,
    Z: NetworkConnectingInterface<C>,
    I: NetworkIncomingInterface<Z>,
    E: NetworkEndpointInterface<Z, I>,
{
    ipv4: Network<E, C, Z, I, { NetworkTypes::QuicIpv4 as u32 }>,
    ipv6: Network<E, C, Z, I, { NetworkTypes::QuicIpv6 as u32 }>,
}

impl<E, C, Z, I> Networks<E, C, Z, I>
where
    C: NetworkConnectionInterface,
    Z: NetworkConnectingInterface<C>,
    I: NetworkIncomingInterface<Z>,
    E: NetworkEndpointInterface<Z, I>,
{
    /// Returns a tuple of:
    /// Self, server_cert, server_addr, net_event_notifier
    pub fn init_server(
        bind_addr_v4: Ipv4Addr,
        bind_addr_v6: Ipv6Addr,
        port_v4: u16,
        port_v6: u16,
        game_event_generator: Arc<dyn NetworkEventToGameEventGenerator + Send + Sync>,
        cert_mode: NetworkServerCertMode,
        sys: &System,
        options: NetworkServerInitOptions,
        plugins: NetworkPlugins,
    ) -> anyhow::Result<(
        Self,
        NetworkServerCertModeResult,
        Vec<SocketAddr>,
        NetworkEventNotifier,
    )> {
        let (ipv4, cert, res_addr1, notifier1) = Network::init_server(
            &format!("{bind_addr_v4}:{port_v4}"),
            game_event_generator.clone(),
            cert_mode.clone(),
            sys,
            options.clone(),
            plugins.clone(),
        )?;
        let (ipv6, _, res_addr2, notifier2) = Network::init_server(
            &format!("[{bind_addr_v6}]:{port_v6}"),
            game_event_generator,
            cert_mode,
            sys,
            options,
            plugins,
        )?;

        Ok((
            Self { ipv4, ipv6 },
            cert,
            vec![res_addr1, res_addr2],
            NetworkEventNotifier {
                notifiers: [
                    notifier1.notifiers[0].clone(),
                    notifier2.notifiers[0].clone(),
                ],
                rt: notifier1.rt,
            },
        ))
    }

    pub fn kick(&self, connection_id: &NetworkConnectionId, ty: KickType) {
        match connection_id.ty() {
            x if x == NetworkTypes::QuicIpv4 as u32 => {
                self.ipv4.kick(connection_id, ty);
            }
            x if x == NetworkTypes::QuicIpv6 as u32 => {
                self.ipv6.kick(connection_id, ty);
            }
            _ => panic!(
                "this network id was not generated by any of these networks. \
                this is an implementation bug."
            ),
        }
    }

    pub fn send_unordered_auto_to<T>(&self, msg: &T, connection_id: &NetworkConnectionId)
    where
        T: Serialize,
    {
        match connection_id.ty() {
            x if x == NetworkTypes::QuicIpv4 as u32 => {
                self.ipv4.send_unordered_auto_to(msg, connection_id);
            }
            x if x == NetworkTypes::QuicIpv6 as u32 => {
                self.ipv6.send_unordered_auto_to(msg, connection_id);
            }
            _ => panic!(
                "this network id was not generated by any of these networks. \
                this is an implementation bug."
            ),
        }
    }

    pub fn send_unordered_to<T>(&self, msg: &T, connection_id: &NetworkConnectionId)
    where
        T: Serialize,
    {
        match connection_id.ty() {
            x if x == NetworkTypes::QuicIpv4 as u32 => {
                self.ipv4.send_unordered_to(msg, connection_id);
            }
            x if x == NetworkTypes::QuicIpv6 as u32 => {
                self.ipv6.send_unordered_to(msg, connection_id);
            }
            _ => panic!(
                "this network id was not generated by any of these networks. \
                this is an implementation bug."
            ),
        }
    }

    pub fn send_in_order_to<T>(
        &self,
        msg: &T,
        connection_id: &NetworkConnectionId,
        channel: NetworkInOrderChannel,
    ) where
        T: Serialize,
    {
        match connection_id.ty() {
            x if x == NetworkTypes::QuicIpv4 as u32 => {
                self.ipv4.send_in_order_to(msg, connection_id, channel);
            }
            x if x == NetworkTypes::QuicIpv6 as u32 => {
                self.ipv6.send_in_order_to(msg, connection_id, channel);
            }
            _ => panic!(
                "this network id was not generated by any of these networks. \
                this is an implementation bug."
            ),
        }
    }

    pub fn send_unreliable_to<T>(&self, msg: &T, connection_id: &NetworkConnectionId)
    where
        T: Serialize,
    {
        match connection_id.ty() {
            x if x == NetworkTypes::QuicIpv4 as u32 => {
                self.ipv4.send_unreliable_to(msg, connection_id);
            }
            x if x == NetworkTypes::QuicIpv6 as u32 => {
                self.ipv6.send_unreliable_to(msg, connection_id);
            }
            _ => panic!(
                "this network id was not generated by any of these networks. \
                this is an implementation bug."
            ),
        }
    }
}
